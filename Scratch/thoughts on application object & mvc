
class Application
{
protected:
  Platform*     m_pPlatform;    
  Window*       m_pMainWindow;  
  RenderSystem* m_pRenderSystem;

  public:
    /** \name Structors */ ///@{
    Application();
    virtual ~Application();
    //@}

    /** \name Accessors */ ///@{
    Platform*     GetPlatform() const       { return m_pPlatform; }
    RenderSystem* GetRenderSystem() const   { return m_pRenderSystem; }
    //@}

    /** \name Mutators */ ///@{
    virtual void Initiate( const char* datadirectory, int w = -1, int h = -1 );
    virtual void Destroy();
    virtual void Run();
    virtual void ProcessFrame( float fTimeElapsed );
  
    void AddInputListener( InputListener* listener );
    void RemoveInputListener( InputListener* listener );
    //@}
	  
}; 


So in this instance StateStack is an extension of Nebulae::Application

void InitiateStateStack( Nebulae::StateStack& stack )
{
  boost::shared_ptr<Game::Model> p( new Game::Model() );
  p->Init();

  stack.Initiate( "../../Samples/Squidish_new/data", 640, 960 );  
  stack.PushState( new Game::SimpleState(p) );
}

int main( int argc, char* argv[] )
{
  // Create the application.
  Nebulae::StateStack app;
  InitiateStateStack( app );
  app.Run();
  return 0;
}


I see this being changed to more of a combination of a ScreenController, Model & View triset.  (Model-View-Controller) with each being independence.


class ExampleApplication : public Application
{
private:
  Model*              m_model;
  EntityRendererView* m_view;
  ScreenController*   m_controller;

  public:
    virtual void ProcessFrame( float fTimeElapsed )
    {
      m_controller->update( fTimeElapsed );
      m_view->render();
    }
};
