DRAW_DEBUG_LINE( world_bottom,  world_left,   vEdgeColour );


void RKRender_InitDebugModule()
{
  RKLOG("RKRender_InitDebugModule()");
  RKRender_DebugRenderLayer = (*RKRender_RenderLayerList)[RK_RENDERLAYER_DEBUG];
  RKRender_DebugGeometryChunk = RKRender_CreateGeometryChunk((RKRenderLayer*)RKRender_DebugRenderLayer);

  RKVertexDeclaration* pDebugDecl = RKTileVertex::Create();

  RKRender_DebugGeometryChunk->m_pMaterial = RKMaterial_Create("vertex_colour"); ///< @todo [will.baker 27.03.2013] Please integrate into the main trunk. Will require vertex_colour material.
  RKRender_DebugGeometryChunk->m_pMaterial->bDepthTest = RKFALSE;
  RKRender_DebugGeometryChunk->m_pMaterial->bDepthWrite = RKTRUE;
  RKRender_DebugGeometryChunk->m_pMaterial->bEnableBlending = RKFALSE;
  RKRender_DebugGeometryChunk->m_matWorld = RKMatrix::identity;
  RKRender_DebugGeometryChunk->m_pIB = 0;
  RKRender_DebugGeometryChunk->m_pRenderLayer = (RKRenderLayer*)RKRender_DebugRenderLayer;
  RKRender_DebugGeometryChunk->m_primitiveCount = 0;
  RKRender_DebugGeometryChunk->m_primitiveType = RKPT_LINELIST;
  RKRender_DebugGeometryChunk->m_pVB = RKVertexBuffer_Create(pDebugDecl, RKRENDER_MAX_DEBUG_LINES*2, RKBUFFER_ACCESS_READ_WRITE, RKBUFFER_UPDATE_OFTEN);

  RKRenderDebug_SphereData = new float[24];
  memset(RKRenderDebug_SphereData, 0x00, 24*4);
  for (int i=0; i<=10; ++i)
  {
    int index = i*2;
    RKRenderDebug_SphereData[index + 0] = sin(i*36.f * RKDEGREES_TO_RADIANS);
    RKRenderDebug_SphereData[index + 1] = cos(i*36.f * RKDEGREES_TO_RADIANS);
  }
}

void RKRender_DrawLine(const RKVector& p0, const RKVector& p1, const RKVector& color)
{
  int primitveCount = RKRender_DebugGeometryChunk->m_primitiveCount;
  if (primitveCount < RKRENDER_MAX_DEBUG_LINES)
  {
    RKTileVertex* pVertexData = (RKTileVertex*)RKVertexBuffer_Lock(RKRender_DebugGeometryChunk->m_pVB);
    if (pVertexData)
    {
      // 2 verts per primitive
      RKTileVertex* pVertex = pVertexData + primitveCount * 2;

      pVertex->position = p0;
      pVertex->uv.Set(0,0);
      pVertex->color.x = color.x; 
      pVertex->color.y = color.y; 
      pVertex->color.z = color.z; 
      pVertex->color.w = 1.f;

      pVertex++;

      pVertex->position = p1;
      pVertex->uv.Set(0,0);
      pVertex->color.x = color.x; 
      pVertex->color.y = color.y; 
      pVertex->color.z = color.z; 
      pVertex->color.w = 1.f;

      RKRender_DebugGeometryChunk->m_primitiveCount++;
      RKVertexBuffer_Unlock(RKRender_DebugGeometryChunk->m_pVB);
    }
  }
}


void RKRender_DrawCircle( const RKVector& position, float radius, const RKVector& colour )
{
  static const int CIRCLE_RESOLUTION = 20;

  for( int i = 0; i < CIRCLE_RESOLUTION; ++i )
  {
    float angle0 = i * (RKTWO_PI / CIRCLE_RESOLUTION);
    float angle1 = angle0 + (RKTWO_PI / CIRCLE_RESOLUTION);
    float x0     = position.x + radius * cos( angle0 );
    float z0     = position.z + radius * sin( angle0 );
    float x1     = position.x + radius * cos( angle1 );
    float z1     = position.z + radius * sin( angle1 );

    RKRender_DrawLine( RKVector(x0, 0, z0), RKVector(x1, 0, z1), colour );
  }
}

void RKRender_DrawAABB(const RKVector& vMin, const RKVector& vMax, const RKVector& vColor)
{
  RKVector v[8];
  v[0].Set(vMin.x, vMin.y, vMin.z);
  v[1].Set(vMax.x, vMin.y, vMin.z);
  v[2].Set(vMax.x, vMin.y, vMax.z);
  v[3].Set(vMin.x, vMin.y, vMax.z);

  v[4].Set(vMin.x, vMax.y, vMin.z);
  v[5].Set(vMax.x, vMax.y, vMin.z);
  v[6].Set(vMax.x, vMax.y, vMax.z);
  v[7].Set(vMin.x, vMax.y, vMax.z);

  DRAW_DEBUG_LINE(v[0], v[1], vColor);
  DRAW_DEBUG_LINE(v[1], v[2], vColor);
  DRAW_DEBUG_LINE(v[2], v[3], vColor);
  DRAW_DEBUG_LINE(v[3], v[0], vColor);

  DRAW_DEBUG_LINE(v[4], v[5], vColor);
  DRAW_DEBUG_LINE(v[5], v[6], vColor);
  DRAW_DEBUG_LINE(v[6], v[7], vColor);
  DRAW_DEBUG_LINE(v[7], v[4], vColor);

  DRAW_DEBUG_LINE(v[0], v[4], vColor);
  DRAW_DEBUG_LINE(v[1], v[5], vColor);
  DRAW_DEBUG_LINE(v[2], v[6], vColor);
  DRAW_DEBUG_LINE(v[3], v[7], vColor);
}

void RKRender_DrawSphere(const RKVector& vSphere, const RKVector& vColor)
{
  int count = 18;

  RKVector vecStart;
  RKVector vecEnd;

  //YZ
  vecEnd.x = vSphere.x;
  vecEnd.y = vSphere.y + vSphere.w * RKRenderDebug_SphereData[0];
  vecEnd.z = vSphere.z + vSphere.w * RKRenderDebug_SphereData[1];
  for (int i=1; i<=10; ++i)
  {
    int index = i*2;
    vecStart = vecEnd;

    vecEnd.y = vSphere.y + vSphere.w * RKRenderDebug_SphereData[index+0];
    vecEnd.z = vSphere.z + vSphere.w * RKRenderDebug_SphereData[index+1];
    DRAW_DEBUG_LINE(vecStart, vecEnd, vColor);
  }

  // XZ
  vecEnd.y = vSphere.y;
  vecEnd.x = vSphere.x + vSphere.w * RKRenderDebug_SphereData[0];
  vecEnd.z = vSphere.z + vSphere.w * RKRenderDebug_SphereData[1];
  for (int i=1; i<=10; ++i)
  {
    int index = i*2;
    vecStart = vecEnd;

    vecEnd.x = vSphere.x + vSphere.w * RKRenderDebug_SphereData[index+0];
    vecEnd.z = vSphere.z + vSphere.w * RKRenderDebug_SphereData[index+1];
    DRAW_DEBUG_LINE(vecStart, vecEnd, vColor);
  }

  // XY
  vecEnd.z = vSphere.z;
  vecEnd.x = vSphere.x + vSphere.w * RKRenderDebug_SphereData[0];
  vecEnd.y = vSphere.y + vSphere.w * RKRenderDebug_SphereData[1];
  for (int i=1; i<=10; ++i)
  {
    int index = i*2;
    vecStart = vecEnd;

    vecEnd.x = vSphere.x + vSphere.w * RKRenderDebug_SphereData[index+0];
    vecEnd.y = vSphere.y + vSphere.w * RKRenderDebug_SphereData[index+1];
    DRAW_DEBUG_LINE(vecStart, vecEnd, vColor);
  }
}

void RKRender_DrawCapsule(const RKVector& p0, const RKVector& p1, float radius, const RKVector& vColor)
{
  RKVector c0 = p0; c0.w = radius;
  RKVector c1 = p1; c1.w = radius;

  RKRender_DrawSphere(c0, vColor);
  RKRender_DrawSphere(c1, vColor);

  DRAW_DEBUG_LINE(p0, p1, vColor);
}